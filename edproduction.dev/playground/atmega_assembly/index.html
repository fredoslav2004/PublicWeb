<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DevSim: AVR ATmega2560</title>
    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #252526;
            --bg-side: #333333;
            --border: #3e3e42;
            --accent: #007acc;
            --accent-hover: #0062a3;
            --text-main: #d4d4d4;
            --text-dim: #858585;
            --error: #f48771;
            --success: #89d185;
            --register: #9cdcfe;
            --opcode: #c586c0;
        }

        * { box-sizing: border-box; }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', 'Consolas', monospace;
            background-color: var(--bg-dark);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Toolbar */
        .toolbar {
            height: 40px;
            background-color: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            flex-shrink: 0;
        }

        .btn {
            background-color: var(--accent);
            color: white;
            border: none;
            padding: 4px 12px;
            border-radius: 2px;
            cursor: pointer;
            font-size: 12px;
            font-family: inherit;
        }
        .btn:hover { background-color: var(--accent-hover); }
        .btn:disabled { background-color: var(--border); cursor: not-allowed; opacity: 0.5; }
        .btn-danger { background-color: #a32a2a; }
        .btn-sm { padding: 2px 6px; font-size: 11px; }

        .status-bar {
            margin-left: auto;
            font-family: monospace;
            font-size: 12px;
            color: var(--text-dim);
            display: flex;
            gap: 15px;
        }
        .status-bar span { color: var(--text-main); font-weight: bold; }

        /* Main Layout */
        .workspace {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar (File Manager) */
        .sidebar {
            width: 200px;
            background-color: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            padding: 10px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .file-list {
            flex: 1;
            overflow-y: auto;
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .file-item {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 13px;
            border-bottom: 1px solid #2d2d2d;
            display: flex;
            justify-content: space-between;
        }
        .file-item:hover { background-color: #2a2d2e; }
        .file-item.active { background-color: #37373d; border-left: 3px solid var(--accent); }
        .file-del { visibility: hidden; color: var(--error); cursor: pointer; }
        .file-item:hover .file-del { visibility: visible; }

        /* Editor Area */
        .editor-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
            min-width: 0;
        }
        
        .tab-bar {
            background-color: var(--bg-dark);
            padding: 5px 10px;
            font-size: 12px;
            color: var(--text-dim);
            border-bottom: 1px solid var(--border);
        }

        .code-container {
            flex: 1;
            position: relative;
            display: flex;
            overflow: hidden;
        }

        .gutter {
            width: 40px;
            background-color: var(--bg-dark);
            border-right: 1px solid var(--border);
            color: var(--text-dim);
            text-align: right;
            padding: 10px 5px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 20px;
            user-select: none;
            overflow: hidden;
        }

        textarea.editor {
            flex: 1;
            background-color: var(--bg-dark);
            color: var(--text-main);
            border: none;
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 14px;
            line-height: 20px;
            resize: none;
            outline: none;
            white-space: pre;
            tab-size: 4;
            overflow: auto;
        }

        .exec-highlight {
            position: absolute;
            left: 0; right: 0;
            height: 20px;
            background-color: rgba(255, 255, 0, 0.15);
            border-left: 2px solid yellow;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        .console {
            height: 150px;
            border-top: 1px solid var(--border);
            background: #111;
            padding: 8px;
            font-family: monospace;
            font-size: 12px;
            overflow-y: auto;
            color: #ccc;
        }
        .log-err { color: var(--error); }
        .log-sys { color: var(--accent); }

        /* Right Panel (Simulation) */
        .sim-panel {
            width: 380px;
            background-color: var(--bg-panel);
            border-left: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-section {
            padding: 10px;
            border-bottom: 1px solid var(--border);
        }
        .section-title {
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            color: var(--text-dim);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
        }

        /* Registers */
        .reg-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 4px;
        }
        .reg-cell {
            background: #333;
            text-align: center;
            padding: 4px 0;
            border-radius: 2px;
            font-size: 11px;
            cursor: help;
        }
        .reg-cell.changed { animation: flash 0.3s ease; background-color: #444; }
        .reg-idx { font-size: 9px; color: var(--register); display: block; }
        .reg-val { font-weight: bold; color: white; }

        /* Flags */
        .flags { display: flex; gap: 5px; justify-content: center; }
        .flag { 
            width: 20px; height: 20px; border: 1px solid #444; 
            display: flex; align-items: center; justify-content: center;
            font-size: 10px; color: #666; border-radius: 3px;
        }
        .flag.on { background-color: var(--accent); color: white; border-color: var(--accent); }

        /* IO */
        .io-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .io-bit { 
            display: flex; flex-direction: column; align-items: center; gap: 2px; 
        }
        .led {
            width: 12px; height: 12px; border-radius: 50%;
            background: #330000; border: 1px solid #555;
        }
        .led.on { background: #ff3333; box-shadow: 0 0 5px #ff3333; }
        input[type="checkbox"] { margin: 0; cursor: pointer; }
        .bit-lbl { font-size: 9px; color: #666; }

        @keyframes flash { 0% { background: var(--accent); } 100% { background: #333; } }
    </style>
</head>
<body>

<div class="toolbar">
    <button class="btn" onclick="asm.assemble()">Assemble</button>
    <button class="btn" onclick="cpu.step()" id="btn-step" disabled>Step</button>
    <button class="btn" onclick="cpu.run()" id="btn-run" disabled>Run</button>
    <button class="btn btn-danger" onclick="cpu.stop()" id="btn-stop" disabled>Stop</button>
    <button class="btn" onclick="cpu.reset()">Reset</button>
    <div style="border-left: 1px solid #444; height: 20px; margin: 0 5px;"></div>
    <button class="btn btn-sm" onclick="cpu.triggerInterrupt(0)">Trig INT0</button>

    <div class="status-bar">
        <span>PC: <span id="disp-pc">0000</span></span>
        <span>SP: <span id="disp-sp">FFFF</span></span>
        <span>Cycles: <span id="disp-cyc">0</span></span>
        <span id="disp-state">IDLE</span>
    </div>
</div>

<div class="workspace">
    <!-- Sidebar -->
    <div class="sidebar">
        <div class="sidebar-header">
            <span>Files</span>
            <button class="btn btn-sm" onclick="fs.createFile()">+</button>
        </div>
        <ul class="file-list" id="file-list">
            <!-- JS populated -->
        </ul>
    </div>

    <!-- Editor -->
    <div class="editor-area">
        <div class="tab-bar" id="current-filename">main.asm</div>
        <div class="code-container">
            <div class="gutter" id="gutter">1</div>
            <textarea class="editor" id="editor" spellcheck="false"></textarea>
            <div class="exec-highlight" id="highlight"></div>
        </div>
        <div class="console" id="console">
            <div class="log-sys">System Ready. ATmega2560 Mode.</div>
        </div>
    </div>

    <!-- Simulation Panel -->
    <div class="sim-panel">
        <!-- Registers -->
        <div class="panel-section">
            <div class="section-title">Registers (R0-R31)</div>
            <div class="reg-grid" id="reg-grid">
                <!-- JS populated -->
            </div>
        </div>

        <!-- SREG -->
        <div class="panel-section">
            <div class="section-title">Status Register (SREG)</div>
            <div class="flags" id="sreg-flags">
                <div class="flag" id="flag-I">I</div>
                <div class="flag" id="flag-T">T</div>
                <div class="flag" id="flag-H">H</div>
                <div class="flag" id="flag-S">S</div>
                <div class="flag" id="flag-V">V</div>
                <div class="flag" id="flag-N">N</div>
                <div class="flag" id="flag-Z">Z</div>
                <div class="flag" id="flag-C">C</div>
            </div>
        </div>

        <!-- IO Ports -->
        <div class="panel-section">
            <div class="section-title">PORT B (0x05)</div>
            <div class="io-row" id="portb-ui"></div>
        </div>
        <div class="panel-section">
            <div class="section-title">PORT D (0x0B) - INT0 on bit 0</div>
            <div class="io-row" id="portd-ui"></div>
        </div>
        
        <div class="panel-section">
            <div class="section-title">Stack (Top 8 Bytes)</div>
            <div style="font-family: monospace; font-size: 11px; color: #aaa;" id="stack-view"></div>
        </div>
    </div>
</div>

<script>
/* * SYSTEM ARCHITECTURE 
 * 1. FileSystem: Manages storage and multiple files.
 * 2. Assembler: Pre-processes (.include) and parses into opcodes. Enforces strict AVR rules.
 * 3. CPU: Executes opcodes, manages SRAM, Stack, and Interrupts.
 * 4. UI: Binds DOM to internal state.
 */

// --- CONSTANTS ---
// 0x2200 = 8704 Bytes. Covers 8KB Internal SRAM (0x200 - 0x21FF) + Registers/IO
const MEM_SIZE = 8704; 
const IO_OFFSET = 0x20; // Offset for memory-mapped IO
const VEC_INT0 = 0x0002; // Interrupt Vector for INT0

// IO Maps (Simplified for 2560)
const IO = {
    PIND: 0x09, DDRD: 0x0A, PORTD: 0x0B,
    PINB: 0x03, DDRB: 0x04, PORTB: 0x05,
    EIMSK: 0x1D, EIFR: 0x1C, SREG: 0x3F, SPL: 0x3D, SPH: 0x3E
};

// --- 1. FILE SYSTEM ---
const fs = {
    files: {},
    activeFile: null,

    init() {
        const saved = localStorage.getItem('avr_files');
        if (saved) {
            try {
                this.files = JSON.parse(saved);
                // Safety check for corrupt empty object
                if (Object.keys(this.files).length === 0) throw new Error("Empty files");
            } catch (e) {
                this.createDefaultFiles();
            }
        } else {
            this.createDefaultFiles();
        }
        
        const keys = Object.keys(this.files);
        // Ensure activeFile is valid
        if (keys.includes('main.asm')) {
            this.activeFile = 'main.asm';
        } else {
            this.activeFile = keys[0]; // Fallback to first file
        }

        this.renderList();
        this.loadEditor();
    },

    createDefaultFiles() {
        this.files = {
            'main.asm': `; Main Entry
.include "defs.inc"

    LDI R16, HIGH(RAMEND)
    OUT SPH, R16
    LDI R16, LOW(RAMEND)
    OUT SPL, R16

    SEI             ; Enable Interrupts
    SBI EIMSK, 0    ; Enable INT0
    
    LDI R20, 0      ; Counter
    LDI R17, 0xFF
    OUT DDRB, R17   ; PORTB Output

LOOP:
    INC R20
    OUT PORTB, R20
    CALL DELAY
    RJMP LOOP

DELAY:
    LDI R18, 10
D_L1: DEC R18
    BRNE D_L1
    RET
`,
            'defs.inc': `; Definitions
.EQU RAMEND = 0x21FF
.EQU EIMSK  = 0x1D
.EQU PORTB  = 0x05
.EQU DDRB   = 0x04
`
        };
    },

    save() {
        if (!this.activeFile) return;
        const content = document.getElementById('editor').value;
        this.files[this.activeFile] = content;
        localStorage.setItem('avr_files', JSON.stringify(this.files));
    },

    select(name) {
        this.save(); // Save current before switch
        this.activeFile = name;
        this.renderList();
        this.loadEditor();
    },

    createFile() {
        const name = prompt("Filename (e.g., lib.asm):");
        if (!name) return;
        if (this.files[name]) {
            alert("File already exists.");
            return;
        }
        this.files[name] = "; New File\n";
        this.select(name);
    },

    deleteFile(name, e) {
        e.stopPropagation();
        if (Object.keys(this.files).length <= 1) return alert("Cannot delete last file.");
        if (!confirm(`Delete ${name}?`)) return;
        delete this.files[name];
        if (this.activeFile === name) this.activeFile = Object.keys(this.files)[0];
        this.renderList();
        this.loadEditor();
        this.save();
    },

    renderList() {
        const ul = document.getElementById('file-list');
        ul.innerHTML = '';
        Object.keys(this.files).forEach(f => {
            const li = document.createElement('li');
            li.className = `file-item ${f === this.activeFile ? 'active' : ''}`;
            li.onclick = () => this.select(f);
            li.innerHTML = `<span>${f}</span> <span class="file-del" onclick="fs.deleteFile('${f}', event)">Ã—</span>`;
            ul.appendChild(li);
        });
        document.getElementById('current-filename').innerText = this.activeFile || 'No File';
    },

    loadEditor() {
        if (!this.activeFile) return;
        document.getElementById('editor').value = this.files[this.activeFile] || "";
        ui.updateGutter();
    },

    // Returns combined source code after resolving includes recursively
    preprocess(filename, visited = []) {
        if (visited.includes(filename)) throw new Error(`Circular dependency: ${filename}`);
        visited.push(filename);
        
        let src = this.files[filename];
        if (typeof src !== 'string') throw new Error(`File not found or corrupt: ${filename}`);

        const lines = src.split('\n');
        let output = [];
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const includeMatch = line.match(/^\s*\.INCLUDE\s+"([^"]+)"/i);
            
            if (includeMatch) {
                // Insert included content with object markers
                output.push({ text: `; --- BEGIN ${includeMatch[1]} ---`, file: filename, lineNum: i + 1 });
                output = output.concat(this.preprocess(includeMatch[1], [...visited]));
                output.push({ text: `; --- END ${includeMatch[1]} ---`, file: filename, lineNum: i + 1 });
            } else {
                output.push({ text: line, file: filename, lineNum: i + 1 });
            }
        }
        return output;
    }
};

// --- 2. ASSEMBLER ---
const asm = {
    labels: {},
    constants: {},
    
    assemble() {
        if (!fs.activeFile) return;
        fs.save(); // Autosave
        cpu.reset();
        ui.log("Assembling...");
        
        try {
            // Preprocess: Flatten includes
            const sourceObj = fs.preprocess(fs.activeFile);
            
            // Pass 1: Constants and Labels
            let pc = 0;
            this.labels = {};
            this.constants = { ...IO }; // Load IO map as constants

            sourceObj.forEach(item => {
                let line = item.text.split(';')[0].trim();
                if (!line) return;

                // Constants
                if (line.toUpperCase().startsWith('.EQU')) {
                    const parts = line.replace(/=/g, ' ').split(/\s+/);
                    if (parts.length >= 3) this.constants[parts[1].toUpperCase()] = parseInt(parts[2]);
                    return;
                }

                // Labels
                if (line.endsWith(':')) {
                    this.labels[line.slice(0, -1)] = pc;
                    return;
                }
                if (line.includes(':')) {
                    const parts = line.split(':');
                    this.labels[parts[0].trim()] = pc;
                    line = parts[1].trim();
                }

                if (line) pc++; // Instruction found
            });

            // Pass 2: Parsing
            const instructions = [];
            pc = 0;

            sourceObj.forEach(item => {
                let line = item.text.split(';')[0].trim();
                if (!line || line.toUpperCase().startsWith('.EQU') || line.toUpperCase().startsWith('.INCLUDE')) return;
                
                if (line.includes(':')) line = line.split(':')[1].trim();
                if (!line) return;

                const tokens = line.replace(/,/g, ' ').split(/\s+/).filter(t=>t);
                const opcode = tokens[0].toUpperCase();
                const args = tokens.slice(1);
                
                const instr = this.parseInstruction(opcode, args, pc, item.lineNum, item.file);
                if (instr) {
                    instructions.push(instr);
                    pc++;
                }
            });

            cpu.load(instructions);
            ui.log(`Success. ${instructions.length} words.`, false, true);
            ui.enableControls(true);

        } catch (e) {
            ui.log(e.message, true);
            console.error(e);
        }
    },

    resolve(val) {
        val = val.trim();
        if (this.constants[val.toUpperCase()] !== undefined) return this.constants[val.toUpperCase()];
        if (this.labels[val] !== undefined) return this.labels[val];
        
        // Helpers: HIGH(val), LOW(val)
        if (val.toUpperCase().startsWith("HIGH(") && val.endsWith(")")) {
            const inner = val.substring(5, val.length-1);
            return (this.resolve(inner) >> 8) & 0xFF;
        }
        if (val.toUpperCase().startsWith("LOW(") && val.endsWith(")")) {
            const inner = val.substring(4, val.length-1);
            return this.resolve(inner) & 0xFF;
        }

        // Hex/Binary/Decimal
        if (val.startsWith('0x') || val.startsWith('$')) return parseInt(val.replace('$','0x'), 16);
        if (val.startsWith('0b')) return parseInt(val.slice(2), 2);
        return parseInt(val);
    },

    parseReg(str) {
        const u = str.toUpperCase();
        if (!u.startsWith('R')) throw new Error("Expected register (R0-R31)");
        const num = parseInt(u.slice(1));
        if (isNaN(num) || num < 0 || num > 31) throw new Error("Invalid register");
        return num;
    },

    parseInstruction(op, args, pc, lineNum, file) {
        const make = (type, op1, op2) => ({ opcode: op, type, op1, op2, src: {file, line: lineNum} });
        
        try {
            // --- Constraints Logic ---
            const requireHighReg = (r) => { if(r<16) throw new Error(`${op} requires R16-R31`); };
            const requireIO = (addr) => { if(addr > 0x3F) throw new Error(`${op} IO address out of range (0x00-0x3F)`); };
            const requireBitIO = (addr) => { if(addr > 0x1F) throw new Error(`${op} IO address out of range (0x00-0x1F)`); };

            switch(op) {
                case 'NOP': return make('NONE');
                case 'SEI': return make('NONE');
                case 'CLI': return make('NONE');
                case 'RET': return make('NONE');
                case 'RETI': return make('NONE');

                case 'LDI': 
                    var r = this.parseReg(args[0]);
                    requireHighReg(r);
                    return make('REG_IMM', r, this.resolve(args[1]));
                
                case 'MOV': return make('REG_REG', this.parseReg(args[0]), this.parseReg(args[1]));
                case 'ADD': return make('REG_REG', this.parseReg(args[0]), this.parseReg(args[1]));
                case 'SUB': return make('REG_REG', this.parseReg(args[0]), this.parseReg(args[1]));
                case 'AND': return make('REG_REG', this.parseReg(args[0]), this.parseReg(args[1]));
                case 'OR':  return make('REG_REG', this.parseReg(args[0]), this.parseReg(args[1]));
                case 'EOR': return make('REG_REG', this.parseReg(args[0]), this.parseReg(args[1]));
                
                case 'INC': return make('REG', this.parseReg(args[0]));
                case 'DEC': return make('REG', this.parseReg(args[0]));

                case 'CPI':
                    var r = this.parseReg(args[0]);
                    requireHighReg(r);
                    return make('REG_IMM', r, this.resolve(args[1]));

                case 'PUSH': return make('REG', this.parseReg(args[0]));
                case 'POP':  return make('REG', this.parseReg(args[0]));

                case 'OUT': 
                    var addr = this.resolve(args[0]);
                    requireIO(addr);
                    return make('IO_REG', addr, this.parseReg(args[1]));
                
                case 'IN': 
                    var addr = this.resolve(args[1]);
                    requireIO(addr);
                    return make('REG_IO', this.parseReg(args[0]), addr);

                case 'SBI': 
                case 'CBI': 
                    var addr = this.resolve(args[0]);
                    requireBitIO(addr);
                    return make('BIT', addr, parseInt(args[1]));

                case 'RJMP': return make('JMP', this.resolve(args[0]) - pc - 1);
                case 'RCALL': return make('JMP', this.resolve(args[0]) - pc - 1);
                case 'CALL': return make('ABS_JMP', this.resolve(args[0]));
                case 'JMP':  return make('ABS_JMP', this.resolve(args[0]));

                case 'BREQ': 
                case 'BRNE': 
                    return make('BRANCH', this.resolve(args[0]) - pc - 1);

                default: throw new Error(`Unknown Opcode: ${op}`);
            }
        } catch(e) {
            throw new Error(`${file}:${lineNum} - ${e.message}`);
        }
    }
};

// --- 3. CPU ---
const cpu = {
    flash: [],
    sram: new Uint8Array(MEM_SIZE),
    reg: new Uint8Array(32),
    pc: 0,
    sp: 0,
    cycles: 0,
    running: false,
    animId: null,
    
    // Interrupt State
    iff: false, // Global Interrupt Flag
    pendingInt: [], // Queue for interrupt triggers

    reset() {
        this.stop();
        this.sram.fill(0);
        this.reg.fill(0);
        this.pc = 0;
        this.sp = 0; // Real hardware defaults to 0, user must set SP
        this.cycles = 0;
        this.iff = false;
        this.pendingInt = [];
        ui.update();
    },

    load(prog) {
        this.flash = prog;
        this.reset();
    },

    triggerInterrupt(vector) {
        // Simplified hardware trigger
        if(vector === 0) { // INT0
            // Set INTF0 flag in EIFR (Bit 0 at 0x1C)
            this.sram[IO.EIFR + IO_OFFSET] |= 1;
            ui.log("Hardware: INT0 Triggered");
        }
    },

    checkInterrupts() {
        if (!this.iff) return; // Global interrupts disabled

        // Check INT0 (Vector 2)
        // Conditions: EIMSK bit 0 set (Enabled) AND EIFR bit 0 set (Flagged)
        const eimsk = this.sram[IO.EIMSK + IO_OFFSET];
        const eifr = this.sram[IO.EIFR + IO_OFFSET];

        if ((eimsk & 1) && (eifr & 1)) {
            this.serviceInterrupt(VEC_INT0);
            // Clear Flag (AVR logic: Writing 1 clears flag, or cleared by HW. Simulating HW clear here)
            this.sram[IO.EIFR + IO_OFFSET] &= ~1; 
        }
    },

    serviceInterrupt(vectorAddr) {
        this.iff = false; // Disable global interrupts
        // Push PC
        this.pushStack((this.pc >> 8) & 0xFF);
        this.pushStack(this.pc & 0xFF);
        this.pc = vectorAddr;
        this.cycles += 4; // Interrupt overhead
    },

    pushStack(val) {
        // SP is 16-bit combined from SPH:SPL in SRAM
        let sp = (this.sram[IO.SPH+IO_OFFSET] << 8) | this.sram[IO.SPL+IO_OFFSET];
        if (sp === 0) { ui.log("Warning: Stack Pointer is 0!", true); }
        
        // Strict Bounds Check
        if (sp >= MEM_SIZE) { throw new Error(`Stack Overflow: Accessing 0x${sp.toString(16)} (Size: 0x${MEM_SIZE.toString(16)})`); }

        this.sram[sp] = val;
        sp = (sp - 1) & 0xFFFF;
        
        this.sram[IO.SPH+IO_OFFSET] = (sp >> 8);
        this.sram[IO.SPL+IO_OFFSET] = (sp & 0xFF);
    },

    popStack() {
        let sp = (this.sram[IO.SPH+IO_OFFSET] << 8) | this.sram[IO.SPL+IO_OFFSET];
        sp = (sp + 1) & 0xFFFF;
        
        if (sp >= MEM_SIZE) { throw new Error(`Stack Underflow/OOB: Accessing 0x${sp.toString(16)}`); }

        const val = this.sram[sp];
        
        this.sram[IO.SPH+IO_OFFSET] = (sp >> 8);
        this.sram[IO.SPL+IO_OFFSET] = (sp & 0xFF);
        return val;
    },

    updateFlags(res, k, isSub) {
        const r = res & 0xFF;
        let s = this.sram[IO.SREG + IO_OFFSET];
        
        // Z: Zero
        if (r === 0) s |= 2; else s &= ~2;
        // N: Negative
        if (r & 0x80) s |= 4; else s &= ~4;
        // C: Carry (Simplified)
        // V: Overflow (Simplified)
        // Correct calculation for SUB/CMP
        
        this.sram[IO.SREG + IO_OFFSET] = s;
    },

    step() {
        if (this.pc >= this.flash.length) {
            this.stop();
            ui.log("End of Code Segment");
            return;
        }

        // 1. Check Interrupts
        this.checkInterrupts();

        // 2. Fetch
        const instr = this.flash[this.pc];
        let nextPC = this.pc + 1;
        let cyc = 1;

        // 3. Execute
        try {
            const sreg = this.sram[IO.SREG + IO_OFFSET];
            
            switch(instr.opcode) {
                case 'NOP': break;
                case 'SEI': this.iff = true; this.sram[IO.SREG+IO_OFFSET] |= 0x80; break;
                case 'CLI': this.iff = false; this.sram[IO.SREG+IO_OFFSET] &= ~0x80; break;
                
                case 'LDI': this.reg[instr.op1] = instr.op2; break;
                
                case 'MOV': this.reg[instr.op1] = this.reg[instr.op2]; break;
                
                case 'ADD': 
                    var r = this.reg[instr.op1] + this.reg[instr.op2];
                    this.reg[instr.op1] = r & 0xFF;
                    this.updateFlags(r);
                    break;
                
                case 'INC': 
                    var r = this.reg[instr.op1] + 1;
                    this.reg[instr.op1] = r & 0xFF;
                    this.updateFlags(r);
                    break;

                case 'DEC': 
                    var r = this.reg[instr.op1] - 1;
                    this.reg[instr.op1] = r & 0xFF;
                    this.updateFlags(r); // Note: DEC doesn't affect C usually, simplified here
                    break;

                case 'CPI': 
                    var r = this.reg[instr.op1] - instr.op2;
                    this.updateFlags(r, null, true);
                    if (instr.op2 > this.reg[instr.op1]) this.sram[IO.SREG+IO_OFFSET] |= 1; // Set Carry
                    else this.sram[IO.SREG+IO_OFFSET] &= ~1;
                    if (r === 0) this.sram[IO.SREG+IO_OFFSET] |= 2; // Zero
                    break;

                case 'PUSH':
                    this.pushStack(this.reg[instr.op1]);
                    cyc = 2;
                    break;

                case 'POP':
                    this.reg[instr.op1] = this.popStack();
                    cyc = 2;
                    break;

                case 'RCALL':
                case 'CALL':
                    // Store Return Address (Next Instruction)
                    this.pushStack((nextPC >> 8) & 0xFF);
                    this.pushStack(nextPC & 0xFF);
                    
                    if(instr.type === 'ABS_JMP') nextPC = instr.op1;
                    else nextPC = this.pc + 1 + instr.op1;
                    cyc = 3;
                    break;

                case 'RET':
                    var low = this.popStack();
                    var high = this.popStack();
                    nextPC = (high << 8) | low;
                    cyc = 4;
                    break;

                case 'RETI':
                    var low = this.popStack();
                    var high = this.popStack();
                    nextPC = (high << 8) | low;
                    this.iff = true; // Re-enable Interrupts
                    this.sram[IO.SREG+IO_OFFSET] |= 0x80;
                    cyc = 4;
                    break;

                case 'OUT':
                    this.sram[instr.op1 + IO_OFFSET] = this.reg[instr.op2];
                    break;
                
                case 'IN':
                    this.reg[instr.op1] = this.sram[instr.op2 + IO_OFFSET];
                    break;

                case 'SBI':
                    this.sram[instr.op1 + IO_OFFSET] |= (1 << instr.op2);
                    cyc = 2;
                    break;

                case 'CBI':
                    this.sram[instr.op1 + IO_OFFSET] &= ~(1 << instr.op2);
                    cyc = 2;
                    break;

                case 'RJMP':
                case 'JMP':
                    if (instr.type === 'ABS_JMP') nextPC = instr.op1;
                    else nextPC = this.pc + 1 + instr.op1;
                    cyc = 2;
                    break;

                case 'BRNE':
                    if (!(sreg & 2)) { nextPC = this.pc + 1 + instr.op1; cyc = 2; }
                    break;
                case 'BREQ':
                    if (sreg & 2) { nextPC = this.pc + 1 + instr.op1; cyc = 2; }
                    break;
            }
        } catch(e) {
            ui.log(`Runtime Error at ${this.pc}: ${e.message}`, true);
            this.stop();
            return;
        }

        this.pc = nextPC;
        this.cycles += cyc;
        ui.update();
    },

    run() {
        if (this.running) return;
        this.running = true;
        const loop = () => {
            if (!this.running) return;
            for(let i=0; i<100; i++) { // Speed multiplier
                this.step();
                if(!this.running) break;
            }
            this.animId = requestAnimationFrame(loop);
        };
        this.animId = requestAnimationFrame(loop);
    },

    stop() {
        this.running = false;
        cancelAnimationFrame(this.animId);
        ui.update();
    }
};

// --- 4. UI ---
const ui = {
    init() {
        // Create Register Grid
        const grid = document.getElementById('reg-grid');
        for(let i=0; i<32; i++) {
            const div = document.createElement('div');
            div.className = 'reg-cell';
            div.innerHTML = `<span class="reg-idx">R${i}</span><span class="reg-val" id="reg-ui-${i}">00</span>`;
            div.title = `R${i} (Decimal: 0)`;
            grid.appendChild(div);
        }

        // IO Pins
        this.createPortUI('portb', IO.PORTB, IO.PINB, IO.DDRB);
        this.createPortUI('portd', IO.PORTD, IO.PIND, IO.DDRD);

        // Editor Events
        const ed = document.getElementById('editor');
        ed.addEventListener('input', () => {
            this.updateGutter();
            fs.save();
        });
        ed.addEventListener('scroll', () => {
            this.updateHighlight();
        });
        
        fs.init();
        cpu.reset(); // Trigger initial update so UI matches CPU state
    },

    createPortUI(id, portAddr, pinAddr, ddrAddr) {
        const container = document.getElementById(`${id}-ui`);
        for(let i=7; i>=0; i--) {
            const div = document.createElement('div');
            div.className = 'io-bit';
            div.innerHTML = `
                <div class="led" id="led-${id}-${i}"></div>
                <input type="checkbox" id="chk-${id}-${i}">
                <span class="bit-lbl">${i}</span>
            `;
            container.appendChild(div);

            // Handle Input Click
            document.getElementById(`chk-${id}-${i}`).addEventListener('change', (e) => {
                const bit = i;
                // If checked, set bit in PIN register (Simulate VCC connection)
                if (e.target.checked) cpu.sram[pinAddr + IO_OFFSET] |= (1 << bit);
                else cpu.sram[pinAddr + IO_OFFSET] &= ~(1 << bit);
                this.update();
            });
        }
    },

    update() {
        document.getElementById('disp-pc').textContent = cpu.pc.toString(16).padStart(4, '0').toUpperCase();
        document.getElementById('disp-cyc').textContent = cpu.cycles;
        
        // Stack Pointer
        const sp = (cpu.sram[IO.SPH+IO_OFFSET] << 8) | cpu.sram[IO.SPL+IO_OFFSET];
        document.getElementById('disp-sp').textContent = sp.toString(16).padStart(4, '0').toUpperCase();
        document.getElementById('disp-state').textContent = cpu.running ? "RUNNING" : "PAUSED";

        // Registers
        for(let i=0; i<32; i++) {
            const el = document.getElementById(`reg-ui-${i}`);
            const val = cpu.reg[i].toString(16).padStart(2, '0').toUpperCase();
            if (el.innerText !== val) {
                el.innerText = val;
                el.parentElement.title = `R${i} (Decimal: ${cpu.reg[i]})`;
                el.parentElement.classList.remove('changed');
                void el.offsetWidth;
                el.parentElement.classList.add('changed');
            }
        }

        // Flags
        const sreg = cpu.sram[IO.SREG + IO_OFFSET];
        ['C','Z','N','V','S','H','T','I'].forEach((f, i) => {
            const el = document.getElementById(`flag-${f}`);
            if ((sreg >> i) & 1) el.classList.add('on'); else el.classList.remove('on');
        });

        // Ports Visuals
        this.updatePortVisual('portb', IO.PORTB, IO.PINB, IO.DDRB);
        this.updatePortVisual('portd', IO.PORTD, IO.PIND, IO.DDRD);

        this.enableControls(!cpu.running);
        if (cpu.running) document.getElementById('btn-stop').disabled = false;

        this.updateHighlight();
        this.updateStackView(sp);
    },

    updatePortVisual(id, portAddr, pinAddr, ddrAddr) {
        // Read PIN register for LED (Voltage on pin)
        // Read PORT register for Pullup/Drive state (internal logic)
        // Read DDR register for direction
        
        const ddr = cpu.sram[ddrAddr + IO_OFFSET];
        const pinVal = cpu.sram[pinAddr + IO_OFFSET];
        
        for(let i=0; i<8; i++) {
            const led = document.getElementById(`led-${id}-${i}`);
            const chk = document.getElementById(`chk-${id}-${i}`);
            
            const isOutput = (ddr >> i) & 1;
            const val = (pinVal >> i) & 1;

            // LED always reflects PIN state (Voltage)
            if (val) led.classList.add('on'); else led.classList.remove('on');

            if (isOutput) {
                chk.disabled = true;
                chk.title = "Pin driven by CPU (Output)";
            } else {
                chk.disabled = false;
                chk.title = "Toggle External Input";
            }
        }
    },

    updateStackView(sp) {
        let html = "";
        for(let i=0; i<8; i++) {
            // Mask to 16-bit to prevent JS undefined if wrapping
            let addr = (sp + 1 + i) & 0xFFFF;
            
            if (addr >= MEM_SIZE) {
                html += `[${addr.toString(16)}] <span style="color:#555">Invalid (OOB)</span> <br>`;
                continue;
            }

            let val = cpu.sram[addr].toString(16).padStart(2,'0');
            html += `[${addr.toString(16)}] ${val} <br>`;
        }
        document.getElementById('stack-view').innerHTML = html || "Empty";
    },

    updateGutter() {
        if (!document.getElementById('editor').value) return;
        const lines = document.getElementById('editor').value.split('\n').length;
        document.getElementById('gutter').innerHTML = Array(lines).fill(0).map((_,i)=>i+1).join('<br>');
    },

    updateHighlight() {
        if (fs.activeFile !== 'main.asm') return; 
        
        const hl = document.getElementById('highlight');
        const ed = document.getElementById('editor');
        
        if (cpu.flash[cpu.pc] && cpu.flash[cpu.pc].src.file === fs.activeFile) {
            const line = cpu.flash[cpu.pc].src.line;
            hl.style.display = 'block';
            // Fixed offset: 10px (padding) + (line-1)*20px (lineheight) - scroll
            hl.style.top = (10 + (line - 1) * 20 - ed.scrollTop) + 'px';
        } else {
            hl.style.display = 'none';
        }
    },

    log(msg, err=false, success=false) {
        const c = document.getElementById('console');
        const d = document.createElement('div');
        d.innerText = `> ${msg}`;
        if (err) d.className = 'log-err';
        if (success) d.style.color = 'var(--success)';
        c.appendChild(d);
        c.scrollTop = c.scrollHeight;
    },

    enableControls(enabled) {
        document.getElementById('btn-step').disabled = !enabled;
        document.getElementById('btn-run').disabled = !enabled;
        document.getElementById('btn-stop').disabled = enabled;
    }
};

ui.init();

</script>
</body>
</html>