<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EdProduction</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
  <style>
    :root { --bg: #0b0b0c; --fg: #EDEDED; --accent: 210 100% 60%; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--fg);
      font-family: "Inter", ui-sans-serif, system-ui, -apple-system, sans-serif;
      overflow: hidden; user-select: none;
    }
    .wrap { position: relative; height: 100vh; width: 100vw; display: grid; place-items: center; }
    
    /* Animation Logic:
       Size is 200%. Beam is in the middle (at 100% width relative to element).
       Start: -200% (Beam is at -100%, fully left of text).
       End: 200% (Beam is at 300%, fully right of text).
    */
    @keyframes textShine {
      0% { background-position: -200% center; }
      100% { background-position: 200% center; }
    }

    h1 {
      position: relative; z-index: 3; margin: 0;
      font-size: clamp(42px, 9vw, 160px); font-weight: 800;
      letter-spacing: -0.02em; line-height: 1; text-align: center;
      pointer-events: none;
      
      /* 1. The Base Color (Solid Dark Grey) - Keeps text visible */
      background-color: #444;
      
      /* 2. The Light Beam (Transparent -> White -> Transparent) */
      background-image: linear-gradient(
        110deg, 
        transparent 45%, 
        #ffffff 50%, 
        transparent 55%
      );
      
      /* Sizing and Clipping */
      background-size: 200% 100%;
      background-repeat: no-repeat;
      background-clip: text;
      -webkit-background-clip: text;
      
      /* Transparent fill lets the background-color + image show through */
      -webkit-text-fill-color: transparent; 
      color: #444; /* Fallback */

      animation: textShine 8s linear infinite;
    }

    .links {
      position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 10;
      display: flex; justify-content: center; gap: 20px;
      pointer-events: none; 
    }

    .ghost-link {
      color: var(--fg); text-decoration: none; font-size: 14px; font-weight: 500;
      text-transform: uppercase; letter-spacing: 0.1em;
      opacity: 0; 
      transition: opacity 0.1s linear, transform 0.2s ease;
      pointer-events: auto; 
      padding: 10px 20px;
      border: 1px solid rgba(255,255,255,0.1); border-radius: 99px;
    }
    
    canvas.fx { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
    #bokeh { z-index: 1; }
    #light { z-index: 2; mix-blend-mode: screen; }
    
    @media (prefers-reduced-motion: reduce) {
      canvas.fx { display: none; }
      .ghost-link { opacity: 1; } 
      h1 { animation: none; -webkit-text-fill-color: var(--fg); background: none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="bokeh" class="fx"></canvas>
    <canvas id="light" class="fx"></canvas>
    <h1>EdProduction</h1>
    
    <div class="links">
      <a href="https://edproduction.dev/playground" class="ghost-link">Playground</a>
      <a href="https://eduardfekete.com" class="ghost-link">Eduard Fekete</a>
    </div>
  </div>

  <script>
  (function(){
    const cb = document.getElementById('bokeh');
    const cl = document.getElementById('light');
    const links = document.querySelectorAll('.ghost-link');
    
    const ctxB = cb.getContext('2d');
    const ctxL = cl.getContext('2d');

    let W = 0, H = 0, T = 0;
    let dpr = 1;
    let isWarping = false;
    let chaos = 0; 
    
    const mouse = { x: -9999, y: -9999, vx: 0, vy: 0 }; 
    const particles = [];
    
    const RANGES = {
      count: [50, 80],
      radius: [2, 60], 
      speed: [0.2, 1.5]
    };

    const PALETTE = [
      [210, 100, 60], 
      [280, 100, 62], 
      [160, 100, 55], 
      [320, 100, 60]  
    ];

    const rand = (min, max) => Math.random() * (max - min) + min;
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

    class Particle {
      constructor() {
        this.init();
      }

      init() {
        const [h, s, l] = pick(PALETTE);
        this.x = rand(0, W);
        this.y = rand(0, H);
        this.r = rand(...RANGES.radius); 
        this.hue = h; this.sat = s; this.lig = l;
        this.a = rand(0.1, 0.5);
        
        this.vx = rand(-0.5, 0.5);
        this.vy = rand(-0.5, 0.5);
        this.friction = 0.96;
      }

      update() {
        this.x += this.vx;
        this.y += this.vy;

        if (chaos > 0.1) {
            const flowAngle = (this.x * 0.002) + (this.y * 0.002) + (T * 0.0005);
            const speed = chaos * 0.08; 
            this.vx += Math.cos(flowAngle) * speed;
            this.vy += Math.sin(flowAngle) * speed;
        }

        const dx = this.x - mouse.x;
        const dy = this.y - mouse.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        
        if (isWarping) {
          const cx = W/2, cy = H/2;
          const ang = Math.atan2(this.y - cy, this.x - cx);
          this.vx += Math.cos(ang) * 2;
          this.vy += Math.sin(ang) * 2;
        } else if (d < 300) {
          const force = (300 - d) / 300;
          const ang = Math.atan2(dy, dx);
          const push = force * 0.5;
          this.vx += Math.cos(ang) * push;
          this.vy += Math.sin(ang) * push;
        }

        this.vx *= this.friction;
        this.vy *= this.friction;

        const timeScale = T * 0.001;
        this.vx += Math.sin(timeScale + this.y * 0.01) * 0.02;
        this.vy += Math.cos(timeScale + this.x * 0.01) * 0.02;

        if (this.x < -this.r) this.x = W + this.r;
        if (this.x > W + this.r) this.x = -this.r;
        if (this.y < -this.r) this.y = H + this.r;
        if (this.y > H + this.r) this.y = -this.r;
      }

      draw(ctx) {
        ctx.beginPath();
        const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.r);
        const alpha = isWarping ? this.a * 1.5 : this.a;
        g.addColorStop(0, `hsla(${this.hue}, ${this.sat}%, ${this.lig}%, ${alpha})`);
        g.addColorStop(1, `hsla(${this.hue}, ${this.sat}%, ${this.lig}%, 0)`);
        ctx.fillStyle = g;
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function init() {
      particles.length = 0;
      const cnt = Math.round(rand(...RANGES.count));
      for(let i=0; i<cnt; i++) particles.push(new Particle());
    }

    function resize() {
      dpr = window.devicePixelRatio || 1;
      W = window.innerWidth;
      H = window.innerHeight;
      [cb, cl].forEach(c => {
        c.width = W * dpr;
        c.height = H * dpr;
        c.getContext('2d').scale(dpr, dpr);
      });
      init();
    }

    function render(now) {
      T = now;
      chaos *= 0.92; 
      if (chaos < 0.01) chaos = 0;

      ctxB.clearRect(0, 0, W, H);
      if(isWarping) {
         ctxB.fillStyle = 'rgba(11, 11, 12, 0.2)';
         ctxB.fillRect(0,0,W,H);
      }

      ctxB.globalCompositeOperation = 'lighter';
      particles.forEach(p => {
        p.update();
        p.draw(ctxB);
      });

      ctxL.clearRect(0, 0, W, H);
      const lx = mouse.x, ly = mouse.y;
      const lightR = 250;
      
      const g = ctxL.createRadialGradient(lx, ly, 0, lx, ly, lightR);
      g.addColorStop(0, 'rgba(255,255,255,0.1)');
      g.addColorStop(0.5, 'rgba(255,255,255,0.02)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctxL.fillStyle = g;
      ctxL.fillRect(0, 0, W, H);

      if (links.length > 0) {
        links.forEach(link => {
          const rect = link.getBoundingClientRect();
          const linkCx = rect.left + rect.width/2;
          const linkCy = rect.top + rect.height/2;
          const dLink = dist(lx, ly, linkCx, linkCy);
          
          let op = 1 - (dLink / 250);
          if (op < 0.05) op = 0.05; 
          if (op > 1) op = 1;
          
          link.style.opacity = op;
          const paraX = (lx - W/2) * 0.02;
          const paraY = (ly - H/2) * 0.02;
          link.style.transform = `translate(${paraX}px, ${paraY}px) scale(${0.9 + (op*0.1)})`;
        });
      }
      requestAnimationFrame(render);
    }

    window.addEventListener('resize', resize);
    window.addEventListener('pointermove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });
    window.addEventListener('pointerdown', () => isWarping = true);
    window.addEventListener('pointerup', () => isWarping = false);
    
    window.addEventListener('wheel', (e) => {
        const strength = Math.min(Math.abs(e.deltaY), 50); 
        chaos += strength * 0.8;
        if (chaos > 60) chaos = 60;
    }, { passive: true });

    resize();
    requestAnimationFrame(render);
  })();
  </script>
</body>
</html>