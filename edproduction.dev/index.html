<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>EdProduction</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap" rel="stylesheet">
  <style>
    :root { --bg: #0b0b0c; --fg: #EDEDED; --accent: 210 100% 60%; }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; background: var(--bg); color: var(--fg);
      font-family: "Inter", ui-sans-serif, system-ui, -apple-system, sans-serif;
      overflow: hidden; user-select: none;
    }
    .wrap { position: relative; height: 100vh; width: 100vw; display: grid; place-items: center; }
    
    h1 {
      position: relative; z-index: 3; margin: 0;
      font-size: clamp(42px, 9vw, 160px); font-weight: 800;
      letter-spacing: -0.02em; line-height: 1; text-align: center;
      pointer-events: none; /* Let clicks pass through to canvas */
      mix-blend-mode: overlay; /* Blends text with particles */
    }

    /* The Subtle Link Container */
    .links {
      position: absolute; bottom: 40px; width: 100%; text-align: center; z-index: 10;
      display: flex; justify-content: center; gap: 20px;
      pointer-events: none; /* Allow click-through unless on exact link */
    }

    /* The Reveal Mechanism */
    .ghost-link {
      color: var(--fg); text-decoration: none; font-size: 14px; font-weight: 500;
      text-transform: uppercase; letter-spacing: 0.1em;
      opacity: 0; /* Hidden by default */
      transition: opacity 0.1s linear, transform 0.2s ease;
      pointer-events: auto; padding: 10px 20px;
      border: 1px solid rgba(255,255,255,0.1); border-radius: 99px;
    }
    
    canvas.fx { position: absolute; inset: 0; width: 100%; height: 100%; display: block; }
    #bokeh { z-index: 1; }
    #light { z-index: 2; mix-blend-mode: screen; }
    
    @media (prefers-reduced-motion: reduce) {
      canvas.fx { display: none; }
      .ghost-link { opacity: 1; } 
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="bokeh" class="fx"></canvas>
    <canvas id="light" class="fx"></canvas>
    <h1>EdProduction</h1>
    
    <!-- Subtle Links Section -->
    <div class="links">
      <a href="https://edproduction.dev/playground" class="ghost-link" id="lnk-playground">Playground</a>
    </div>
  </div>

  <script>
  (function(){
    const cb = document.getElementById('bokeh');
    const cl = document.getElementById('light');
    const link = document.getElementById('lnk-playground');
    const ctxB = cb.getContext('2d');
    const ctxL = cl.getContext('2d');

    // State
    let W = 0, H = 0, T = 0;
    let dpr = 1;
    let isWarping = false;
    
    const mouse = { x: -9999, y: -9999, vx: 0, vy: 0 }; // Init off-screen
    const particles = [];
    
    const RANGES = {
      count: [50, 80],
      radius: [2, 60], // Varied sizes for depth
      speed: [0.2, 1.5]
    };

    const PALETTE = [
      [210, 100, 60], // Blue
      [280, 100, 62], // Violet
      [160, 100, 55], // Teal
      [320, 100, 60]  // Pink
    ];

    // --- Math Utils ---
    const rand = (min, max) => Math.random() * (max - min) + min;
    const pick = (arr) => arr[Math.floor(Math.random() * arr.length)];
    const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);

    class Particle {
      constructor() {
        this.init();
      }

      init() {
        const [h, s, l] = pick(PALETTE);
        this.x = rand(0, W);
        this.y = rand(0, H);
        this.r = rand(...RANGES.radius); // visual radius
        this.hue = h; this.sat = s; this.lig = l;
        this.a = rand(0.1, 0.5);
        
        // Physics props
        this.vx = rand(-0.5, 0.5);
        this.vy = rand(-0.5, 0.5);
        this.friction = 0.96;
        this.mass = this.r * 0.5; // Heavy particles move slower
      }

      update(dt) {
        // 1. Basic movement
        this.x += this.vx;
        this.y += this.vy;

        // 2. Mouse Interaction (Repulsion/Warp)
        const dx = this.x - mouse.x;
        const dy = this.y - mouse.y;
        const d = Math.sqrt(dx*dx + dy*dy);
        
        if (isWarping) {
          // WARP SPEED: Suck into center then explode or stream
          // Simple implementation: Stream away from center at high speed
          const cx = W/2, cy = H/2;
          const ang = Math.atan2(this.y - cy, this.x - cx);
          this.vx += Math.cos(ang) * 2;
          this.vy += Math.sin(ang) * 2;
        } else if (d < 300) {
          // MOUSE WAKE: Push away gently based on mouse movement
          const force = (300 - d) / 300;
          const ang = Math.atan2(dy, dx);
          const push = force * 0.5;
          this.vx += Math.cos(ang) * push;
          this.vy += Math.sin(ang) * push;
        }

        // 3. Friction & Limits
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Constant ambient float
        const timeScale = T * 0.001;
        this.vx += Math.sin(timeScale + this.y * 0.01) * 0.02;
        this.vy += Math.cos(timeScale + this.x * 0.01) * 0.02;

        // 4. Wrap around
        if (this.x < -this.r) this.x = W + this.r;
        if (this.x > W + this.r) this.x = -this.r;
        if (this.y < -this.r) this.y = H + this.r;
        if (this.y > H + this.r) this.y = -this.r;
      }

      draw(ctx) {
        ctx.beginPath();
        const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.r);
        // Warping changes color intensity
        const alpha = isWarping ? this.a * 1.5 : this.a;
        g.addColorStop(0, `hsla(${this.hue}, ${this.sat}%, ${this.lig}%, ${alpha})`);
        g.addColorStop(1, `hsla(${this.hue}, ${this.sat}%, ${this.lig}%, 0)`);
        ctx.fillStyle = g;
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function init() {
      particles.length = 0;
      const cnt = Math.round(rand(...RANGES.count));
      for(let i=0; i<cnt; i++) particles.push(new Particle());
    }

    function resize() {
      dpr = window.devicePixelRatio || 1;
      W = window.innerWidth;
      H = window.innerHeight;
      [cb, cl].forEach(c => {
        c.width = W * dpr;
        c.height = H * dpr;
        c.getContext('2d').scale(dpr, dpr);
      });
      init();
    }

    // --- Render Loop ---
    function render(now) {
      T = now;
      
      // 1. Particles
      ctxB.clearRect(0, 0, W, H);
      // Subtle trail effect during warp
      if(isWarping) {
         ctxB.fillStyle = 'rgba(11, 11, 12, 0.2)';
         ctxB.fillRect(0,0,W,H);
      }

      ctxB.globalCompositeOperation = 'lighter';
      particles.forEach(p => {
        p.update();
        p.draw(ctxB);
      });

      // 2. Light & Link Reveal Logic
      ctxL.clearRect(0, 0, W, H);
      
      // Draw Flashlight
      const lx = mouse.x, ly = mouse.y;
      const lightR = 250;
      
      // Draw the cursor light on canvas
      const g = ctxL.createRadialGradient(lx, ly, 0, lx, ly, lightR);
      g.addColorStop(0, 'rgba(255,255,255,0.1)');
      g.addColorStop(0.5, 'rgba(255,255,255,0.02)');
      g.addColorStop(1, 'rgba(255,255,255,0)');
      ctxL.fillStyle = g;
      ctxL.fillRect(0, 0, W, H);

      // DOM MANIPULATION in the loop (synced with physics)
      // Calculate distance from mouse to link center
      if (link) {
        const rect = link.getBoundingClientRect();
        const linkCx = rect.left + rect.width/2;
        const linkCy = rect.top + rect.height/2;
        const dLink = dist(lx, ly, linkCx, linkCy);
        
        // Map distance to opacity. 0 distance = 1 opacity. 200 distance = 0.1 opacity.
        // Clamp minimum opacity to 0.05 so it's barely there, max 1.
        let op = 1 - (dLink / 250);
        if (op < 0.05) op = 0.05; 
        if (op > 1) op = 1;
        
        link.style.opacity = op;
        // Slight parallax for the link button itself (fun detail)
        const paraX = (lx - W/2) * 0.02;
        const paraY = (ly - H/2) * 0.02;
        link.style.transform = `translate(${paraX}px, ${paraY}px) scale(${0.9 + (op*0.1)})`;
      }

      requestAnimationFrame(render);
    }

    // --- Inputs ---
    window.addEventListener('resize', resize);
    window.addEventListener('pointermove', e => {
      mouse.x = e.clientX;
      mouse.y = e.clientY;
    });
    window.addEventListener('pointerdown', () => isWarping = true);
    window.addEventListener('pointerup', () => isWarping = false);

    // Boot
    resize();
    requestAnimationFrame(render);
  })();
  </script>
</body>
</html>